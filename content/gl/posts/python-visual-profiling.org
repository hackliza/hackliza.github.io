#+title: Profiling visual para Python
#+author: Sergio Mart铆nez Portela
#+date: 2022-06-26
#+tags[]: python profiling optimizaci贸n flamegraph

Boas, xente.

Hoxe ve帽o cun exemplo pr谩ctico de como podemos analizar os nosos programas de Python para atopar facilmente pescozos de botella.

F谩lase moito de como as optimizaci贸ns non se deben facer a cegas, sen贸n que hai que medir que partes dun programa son as problem谩ticas para conseguir mellorar a execuci贸n do c贸digo de xeito eficiente. Hoxe veremos como facelo de forma c贸moda e pr谩ctica.

* Gr谩ficos de lapas (Flame Graphs)
Hai moitos xeitos de medir e visualizar o comportamento dunha aplicaci贸n, pero persoalmente o que m谩is c贸modo me parece 茅 a t茅cnica dos [[https://www.brendangregg.com/flamegraphs.html][Gr谩ficos de lapas (Flame Graphs) descrito por Brendan Gregg]]. Consiste en medir canto tempo se adica a execuci贸n dunha pila de funci贸ns e debuxalo apilando as funci贸ns que chaman unhas a outras de xeito que canto m谩is espazo horizontal ocupe unha funci贸n, m谩is tempo lle adica o c贸digo a executala.

[[https://www.brendangregg.com/FlameGraphs/cpu-mysql-updated.svg]]
[[https://www.brendangregg.com/FlameGraphs/cpu-mysql-updated.svg][[Preme aqu铆 para ver a imaxe de xeito interactivo]]]

 moi interesante como forma de explorar a execuci贸n do programa, xa que permite facer "zoom" de forma interactiva na mesma imaxe. Proba a abrir a imaxe anterior seguindo a ligaz贸n e preme en ~mysqld`mysql_parse~ e ver谩s que expande esa funci贸n pra ocupar todo o espazo horizontal, de xeito que se pode apreciar mellor os tempos que toma cada funci贸n a que chama esta.

Ou pasando o cursor por enriba dunha funci贸n, coma ~mysqld`mysql_exec~, podemos ver a porcentaxe do tempo de execuci贸n do programa que se emprega dentro de esta chamada, neste caso o =83.77%= .

[[./zoom_sample_image.png]]

* Obtendo os datos
Ben, agora que entendemos como ler os /Flame Graphs/ vexamos como xerar un n贸s mesmos. Para poder facer medidas vamos necesitar alg煤n programa que medir, as铆 que usaremos este, pero o proceso 茅 o mesmo pra todos.

Algo a ter conta 茅 que esta t茅cnica (e outras moitas de profiling) dividen o tempo de execuci贸n por funci贸ns. As铆 que se as funci贸ns son moi longas pode ser necesario dividilas en funci贸ns pequenas, para ter unha idea m谩is clara de que parte do c贸digo 茅 o que consume m谩is tempo.

Ent贸n, como ilustraci贸n usaremos este programa:
#+BEGIN_SRC python
  # Programa de exemplo, estudar茅molo e veremos como se divide o seu rendemento
  def fibonacci(n):
      """Simplemente unha funci贸n de exemplo."""
      if n == 0:
          return 0
      elif n < 2:
          return 1
      else:
          return fibonacci(n - 1) + fibonacci(n - 2)


  def factorial(n):
      """Outra funci贸n de exemplo."""
      if n < 2:
          return 1
      else:
          return n * factorial(n - 1)

  def fibonacci_plus_factorial(n):
      """Funci贸n que chama as d煤as."""
      fib = fibonacci(n)
      fact = factorial(n)
      return fib + fact

  if __name__ == '__main__':
      N = 35
      print("[Test] Fibonacci(5): {:3d} = 5 ?".format(fibonacci(5)))
      print("[Test] Factorial(5): {:3d} = 120 ?".format(factorial(5)))
      print("Resultado:", fibonacci_plus_factorial(N))
#+END_SRC

Se executamos este c贸digo veremos que 茅 algo lento:
#+BEGIN_SRC text
  $ time python sample.py
  [Test] Fibonacci(5):   5 = 5 ?
  [Test] Factorial(5): 120 = 120 ?
  Resultado:  10333147966386144929666651337523209227465

  real	0m3,905s
  user	0m3,896s
  sys	0m0,004s
#+END_SRC

Vexamos ent贸n que e o que est谩 tomando m谩is tempo utilizando /Flame Graphs/.

* Preparando o entorno
Pra tomar as medidas podemos utilizar o paquete [[https://github.com/evanhempel/python-flamegraph/][python-flamegraph]]. Normalmente recomendar铆a obtelo do repositorio orixinal, pero este est谩 desactualizado e non funciona cunha versi贸n recente de Python.

Por sorte hai [[https://github.com/evanhempel/python-flamegraph/network][varias persoas que mante帽en forks m谩is actualizados]]. O seu 茅 escoller un cos cambios necesarios e as funcionalidades que nos interesen, e revisar os commits intermedios pra asegurarnos que non se introduciron cambios maliciosos antes de instalalo. A verdade e que normalmente neste punto non me quero complicar moito a vida e non vou utilizar o /profiler/ de forma activa en c贸digo exposto a internet, asi que buscando un cos cambios m铆nimos imprescindibles [[https://github.com/evanhempel/python-flamegraph/compare/master...nickodell:master][podemos atopar o fork de nickodell]]. (Se buscades algo m谩is *serio* bot谩delle un ollo [[https://github.com/IceTDrinker/python-flamegraph/commit/74312897641a3b86f569b40627e3ad0e4f9edd69][a esta nota]]).

Para instalar esta versi贸n do paquete directamente a partir do GitHub podemos facer:
#+BEGIN_SRC shell
  pip install git+https://github.com/nickodell/python-flamegraph.git
#+END_SRC

O seguinte necesario ser谩 clonar este repositorio pra poder xerar of /Flame Graphs/ a partir dos datos recollidos: https://github.com/brendangregg/FlameGraph
#+BEGIN_SRC shell
  git clone https://github.com/brendangregg/FlameGraph
#+END_SRC

* Tomando medidas e analizando
Unha vez temos todo preparado podemos medir o noso programa nun comando:
#+BEGIN_SRC shell
  python -m flamegraph -o medida.log sample.py
#+END_SRC

Esto producir谩 un ficheiro =medida.log= cos datos necesarios. Pra convertelo nunha imaxe de /Flame Graph/ podemos executar isto (adaptando a ruta inicial a onde se haia clonado o repo [[https://github.com/brendangregg/FlameGraph][brendangregg/FlameGraph]]):
#+BEGIN_SRC shell
  FlameGraph/flamegraph.pl medida.log > medida.svg
#+END_SRC

Isto producir谩 un ficheiro =medida.svg= que poderemos abrir cun navegador:

[[./medida1.svg]]
[[./medida1.svg][(Preme aqu铆 pra abrilo en modo interactivo)]]

Podemos observar que, de forma desproporcionada, a maior parte da execuci贸n se adica a funci贸n ~fibonacci~, as铆 que optimic茅mola. Como facer isto depende de cada funci贸n, neste caso podemos pasala de forma recursiva a iterativa:

#+BEGIN_SRC python
  def fibonacci(n):
      """Simplemente unha funci贸n de exemplo, agora optimizada."""
      seq = [0, 1]
      while n >= len(seq):
          seq.append(seq[-1] + seq[-2])

      return seq[n]
#+END_SRC

Se executamos este c贸digo veremos que gran parte da carga de execuci贸n xa se resolveu:
#+BEGIN_SRC text
  $ time python sample.py
  [Test] Fibonacci(5):   5 = 5 ?
  [Test] Factorial(5): 120 = 120 ?
  Resultado:  10333147966386144929666651337523209227465

  real	0m0,029s
  user	0m0,017s
  sys	0m0,012s
#+END_SRC

Sorprendentemente, podemos ver que non 茅 necesario optimizar a funci贸n ~factorial~ inda que tam茅n sexa recursiva, e polo tanto poder铆a parecer que 茅 necesario optimizala. Realmente no caso efectivo a sua execuci贸n 茅 bastante eficiente.

* Pechando
Vemos as铆 que utilizando estes diagramas podemos buscar en que parte do programa nos podemos centrar pra optimizalo de forma r谩pida.

Normalmente non 茅 posible optimizar un programa s贸 facendoo cunha soa funci贸n, sen贸n que 茅 un proceso iterativo:
- Medir os tempos
- Optimizar funci贸n que toma m谩is tempo
- Repetir ata que esteamos contentos co tempo de execuci贸n

E, pra ser sinceiro, o obxectivo deste exemplo era aplicar a optimizaci贸n sobre as d煤as funci贸ns, amosando este ciclo iterativo. Pero ir贸nicamente a mi帽a suposici贸n de que a funci贸n ~factorial~ ser铆a lenta resultou ser falsa, co que teredes que crerme cando vos digo que non soe funcionar nun paso . Isto nos amosa a lecci贸n m谩is importante que se pode aprender sobre optimizaci贸n:

*Antes de cambiar nada, mide o teu programa!*

E pouco m谩is vos podo contar, espero que vos resulte 煤til. Le茅monos!
